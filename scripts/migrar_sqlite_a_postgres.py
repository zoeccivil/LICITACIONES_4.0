#!/usr/bin/env python3
"""
Script para migrar datos de SQLite a PostgreSQL.

Este script lee datos de la base de datos SQLite existente y
los inserta masivamente en PostgreSQL con las conversiones de tipo apropiadas.
"""

import argparse
import sqlite3
import sys
from pathlib import Path
from typing import Dict, List, Any, Tuple
from datetime import datetime
import os

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from dotenv import load_dotenv
from sqlalchemy import text
from db import get_session, get_engine

# Load environment variables
load_dotenv()


# Tables in dependency order (must insert parents before children)
TABLE_ORDER = [
    # Tablas maestras (sin dependencias)
    'categorias',
    'cuentas',
    'instituciones_maestras',
    'empresas_maestras',
    'competidores_maestros',
    'responsables_maestros',
    'config_app',
    'criterios_bnb',
    'documentos_maestros',
    
    # Tablas secundarias
    'kits_de_requisitos',
    'kit_items',
    'subcategorias',
    'proyectos',
    'proyecto_cuentas',
    'presupuestos',
    'transacciones',
    
    # Licitaciones y relacionadas
    'licitaciones',
    'lotes',
    'documentos',
    'oferentes',
    'ofertas_lote_oferentes',
    'bnb_evaluaciones',
    'descalificaciones_fase_a',
    'expedientes',
    'expediente_items',
    'ganadores_canonicos',
    'historial_ganadores',
    'licitacion_empresas_nuestras',
    'licitacion_ganadores_lote',
    'riesgos',
    'subsanacion_historial',
    
    # Tablas de utilidad
    'backups_log',
    'schema_migrations',
]


def convert_sqlite_value(value: Any, column_type: str) -> Any:
    """
    Convertir valor SQLite a valor compatible con PostgreSQL.
    
    Args:
        value: The value to convert
        column_type: The SQLite column type
        
    Returns:
        Converted value suitable for PostgreSQL
    """
    if value is None:
        return None
    
    column_type = column_type.upper()
    
    # Boolean conversion
    if 'BOOLEAN' in column_type or 'BOOL' in column_type:
        if isinstance(value, (int, str)):
            return bool(int(value)) if str(value).isdigit() else value.lower() in ('true', 't', 'yes', 'y', '1')
        return bool(value)
    
    # Date/time conversion - convert TEXT dates to proper timestamps
    if 'TIMESTAMP' in column_type or 'DATETIME' in column_type:
        if isinstance(value, str):
            # Try various date formats
            for fmt in [
                '%Y-%m-%d %H:%M:%S.%f',
                '%Y-%m-%d %H:%M:%S',
                '%Y-%m-%d %H:%M',
                '%Y-%m-%d',
            ]:
                try:
                    return datetime.strptime(value, fmt)
                except ValueError:
                    continue
            # If no format matches, return as-is (PostgreSQL may be able to parse it)
            return value
        return value
    
    # Numeric types
    if 'INTEGER' in column_type or 'INT' in column_type:
        if isinstance(value, str) and value.strip() == '':
            return None
        try:
            return int(value)
        except (ValueError, TypeError):
            return value
    
    if 'REAL' in column_type or 'FLOAT' in column_type or 'DOUBLE' in column_type:
        if isinstance(value, str) and value.strip() == '':
            return None
        try:
            return float(value)
        except (ValueError, TypeError):
            return value
    
    # Default: return as-is
    return value


def get_table_data(sqlite_conn: sqlite3.Connection, table_name: str) -> Tuple[List[str], List[Dict[str, Any]]]:
    """
    Obtener todos los datos de una tabla SQLite.
    
    Args:
        sqlite_conn: SQLite connection
        table_name: Name of the table
        
    Returns:
        Tuple of (column_names, rows)
    """
    # Get column info
    cursor = sqlite_conn.execute(f"PRAGMA table_info({table_name})")
    columns_info = cursor.fetchall()
    column_names = [col[1] for col in columns_info]
    column_types = {col[1]: col[2] for col in columns_info}
    
    # Skip auto-increment columns (they'll be generated by SERIAL)
    pk_columns = [col[1] for col in columns_info if col[5] > 0]  # col[5] is pk flag
    
    # Get data
    cursor = sqlite_conn.execute(f"SELECT * FROM {table_name}")
    rows = []
    
    for row in cursor.fetchall():
        row_dict = {}
        for i, col_name in enumerate(column_names):
            # Skip SERIAL primary key columns - they'll auto-increment
            if col_name == 'id' and col_name in pk_columns and column_types.get(col_name, '').upper() == 'INTEGER':
                continue
            
            value = row[i]
            row_dict[col_name] = convert_sqlite_value(value, column_types.get(col_name, 'TEXT'))
        
        rows.append(row_dict)
    
    return column_names, rows


def insert_data_bulk(session, table_name: str, rows: List[Dict[str, Any]]) -> int:
    """
    Insertar datos masivamente en tabla PostgreSQL.
    
    Args:
        session: SQLAlchemy session
        table_name: Name of the table
        rows: List of row dictionaries
        
    Returns:
        Number of rows inserted
    """
    if not rows:
        return 0
    
    # Get column names from first row
    columns = list(rows[0].keys())
    
    # Build parameterized INSERT statement
    placeholders = ", ".join([f":{col}" for col in columns])
    column_list = ", ".join(columns)
    
    sql = f"INSERT INTO {table_name} ({column_list}) VALUES ({placeholders})"
    
    # Execute bulk insert
    session.execute(text(sql), rows)
    
    return len(rows)


def reset_sequences(session, table_name: str):
    """
    Reiniciar la secuencia para columnas SERIAL a max(id) + 1.
    
    Args:
        session: SQLAlchemy session
        table_name: Name of the table
    """
    try:
        # Find the sequence name (usually tablename_id_seq)
        sequence_name = f"{table_name}_id_seq"
        
        # Set sequence to max(id) + 1
        session.execute(text(f"""
            SELECT setval('{sequence_name}', 
                          COALESCE((SELECT MAX(id) FROM {table_name}), 1), 
                          true)
        """))
    except Exception as e:
        # Not all tables have id sequences, so this is OK
        pass


def migrate_table(sqlite_conn: sqlite3.Connection, table_name: str) -> Dict[str, Any]:
    """
    Migrar una sola tabla de SQLite a PostgreSQL.
    
    Args:
        sqlite_conn: SQLite connection
        table_name: Name of the table to migrate
        
    Returns:
        Migration statistics
    """
    print(f"Migrando tabla: {table_name}...", end=" ", flush=True)
    
    try:
        # Get data from SQLite
        column_names, rows = get_table_data(sqlite_conn, table_name)
        
        if not rows:
            print(f"✓ (0 rows)")
            return {'table': table_name, 'rows': 0, 'success': True}
        
        # Insert into PostgreSQL
        with get_session() as session:
            with session.begin():
                count = insert_data_bulk(session, table_name, rows)
                reset_sequences(session, table_name)
        
        print(f"✓ ({count} rows)")
        return {'table': table_name, 'rows': count, 'success': True}
        
    except Exception as e:
        print(f"✗ ERROR: {e}")
        return {'table': table_name, 'rows': 0, 'success': False, 'error': str(e)}


def verify_migration(sqlite_conn: sqlite3.Connection) -> Dict[str, Tuple[int, int]]:
    """
    Verificar que los conteos de filas coincidan entre SQLite y PostgreSQL.
    
    Args:
        sqlite_conn: SQLite connection
        
    Returns:
        Dictionary mapping table_name -> (sqlite_count, postgres_count)
    """
    results = {}
    
    with get_session() as session:
        for table_name in TABLE_ORDER:
            # Count in SQLite
            cursor = sqlite_conn.execute(f"SELECT COUNT(*) FROM {table_name}")
            sqlite_count = cursor.fetchone()[0]
            
            # Count in PostgreSQL
            result = session.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
            pg_count = result.scalar()
            
            results[table_name] = (sqlite_count, pg_count)
    
    return results


def main():
    """Main migration function."""
    parser = argparse.ArgumentParser(
        description='Migrate data from SQLite to PostgreSQL'
    )
    parser.add_argument(
        '--sqlite',
        required=True,
        help='Path to SQLite database file'
    )
    parser.add_argument(
        '--skip-verification',
        action='store_true',
        help='Skip verification step'
    )
    parser.add_argument(
        '--tables',
        nargs='+',
        help='Migrate only specific tables (in dependency order)'
    )
    
    args = parser.parse_args()
    
    # Check if SQLite file exists
    sqlite_path = Path(args.sqlite)
    if not sqlite_path.exists():
        print(f"Error: SQLite database not found: {sqlite_path}")
        return 1
    
    # Check PostgreSQL connection
    engine = get_engine()
    if engine is None:
        print("Error: PostgreSQL engine not initialized.")
        print("Please check your .env file and database configuration.")
        return 1
    
    print("=" * 70)
    print("Migración de Datos PostgreSQL")
    print("=" * 70)
    print(f"Source (SQLite): {sqlite_path}")
    print(f"Target (PostgreSQL): {os.getenv('DB_HOST')}:{os.getenv('DB_PORT')}/{os.getenv('DB_NAME')}")
    print("=" * 70)
    print()
    
    # Test PostgreSQL connection
    try:
        with get_session() as session:
            result = session.execute(text("SELECT version()"))
            version = result.scalar()
            print(f"✓ Connected to PostgreSQL")
            print(f"  Version: {version[:60]}...")
    except Exception as e:
        print(f"✗ Failed to connect to PostgreSQL: {e}")
        return 1
    
    print()
    
    # Connect to SQLite
    try:
        sqlite_conn = sqlite3.connect(str(sqlite_path))
        print(f"✓ Connected to SQLite: {sqlite_path}")
    except Exception as e:
        print(f"✗ Failed to connect to SQLite: {e}")
        return 1
    
    print()
    print("-" * 70)
    print("Iniciando migración...")
    print("-" * 70)
    print()
    
    # Determine which tables to migrate
    tables_to_migrate = args.tables if args.tables else TABLE_ORDER
    
    # Migrate each table
    results = []
    total_rows = 0
    failed_tables = []
    
    for table_name in tables_to_migrate:
        if table_name not in TABLE_ORDER:
            print(f"Warning: Table '{table_name}' not in dependency order, skipping...")
            continue
        
        result = migrate_table(sqlite_conn, table_name)
        results.append(result)
        
        if result['success']:
            total_rows += result['rows']
        else:
            failed_tables.append(table_name)
    
    print()
    print("-" * 70)
    print("Resumen de Migración")
    print("-" * 70)
    print(f"Total rows migrated: {total_rows}")
    print(f"Tables processed: {len(results)}")
    print(f"Successful: {sum(1 for r in results if r['success'])}")
    print(f"Failed: {len(failed_tables)}")
    
    if failed_tables:
        print()
        print("Tablas fallidas:")
        for table in failed_tables:
            print(f"  - {table}")
    
    # Verification
    if not args.skip_verification and not failed_tables:
        print()
        print("-" * 70)
        print("Verificando migración...")
        print("-" * 70)
        print()
        
        verification = verify_migration(sqlite_conn)
        mismatches = []
        
        print(f"{'Table':<30} {'SQLite':>10} {'PostgreSQL':>12} {'Status':>10}")
        print("-" * 70)
        
        for table_name in tables_to_migrate:
            if table_name not in verification:
                continue
            
            sqlite_count, pg_count = verification[table_name]
            match = "✓" if sqlite_count == pg_count else "✗ MISMATCH"
            
            if sqlite_count != pg_count:
                mismatches.append(table_name)
            
            print(f"{table_name:<30} {sqlite_count:>10} {pg_count:>12} {match:>10}")
        
        if mismatches:
            print()
            print("⚠ Row count mismatches detected in the following tables:")
            for table in mismatches:
                print(f"  - {table}")
            return 1
        else:
            print()
            print("✓ All table row counts match!")
    
    sqlite_conn.close()
    
    print()
    print("=" * 70)
    print("¡Migración completada exitosamente!" if not failed_tables else "¡Migración completada con errores!")
    print("=" * 70)
    
    return 1 if failed_tables else 0


if __name__ == "__main__":
    sys.exit(main())
